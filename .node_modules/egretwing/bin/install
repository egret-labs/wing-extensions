#!/usr/bin/env node

var semver = require('semver');
var fs = require('fs');
var path = require('path');
var request = require('../core/request');

var sources = [
    'https://raw.githubusercontent.com/egret-labs/wing-extensions',
    'https://coding.net/u/xzper/p/wing-extensions/git/raw'
];
var sourceIndex = 0;

process.on('uncaughtException', function (err) {
    exitWithError(err);
});

var engine = process.env.npm_package_engines_wing;
if (!engine) {
    exitWithError('Missing wing engine declaration in package.json.');
}

var wingDtsTypescriptPath = path.join(path.dirname(__dirname), 'wing.d.ts');

console.log('Detected wing engine version: ' + engine);

var loadNextSource = function (error) {
    if (++sourceIndex < sources.length) {
        return getURLMatchingEngine(engine, matchingEngine);
    } else {
        return exitWithError(error);
    }
}

var matchingEngine = function (error, url) {
    if (error) {
        return loadNextSource(error);
    }

    console.log('Fetching wing.d.ts from: ' + url);

    getContents(url, function (error, contents) {
        if (error) {
            return loadNextSource(error);
        }

        fs.writeFileSync(wingDtsTypescriptPath, contents);

        console.log('wing.d.ts successfully installed!\n');
    });
};

getURLMatchingEngine(engine, matchingEngine);

function wingDtsToTypescript(contents) {
    var markerHit = false;
    var lines = contents.split('\n').filter(function (line) {
        if (!markerHit && (line === '// when used for JS*' || line === 'declare module \'wing\' {')) {
            markerHit = true;
        }

        return !markerHit;
    });

    lines.push('export = wing;'); // this is to enable TS module resolution support

    return lines.join('\n');
}

function wingDtsToJavaScript(contents) {
    return contents; // contents are already compatible with JS
}

function getURLMatchingEngine(engine, callback) {
    var currentSource = sources[sourceIndex];

    if (engine === '*') {
        return callback(null, currentSource + '/master/.apis/wing.d.ts'); // master
    }

    getContents(currentSource + '/master/package.json', function (error, packageRaw) {
        if (error) {
            return callback(error);
        }
        packageRaw = (packageRaw && JSON.parse(packageRaw)) || {};
        var tags = packageRaw.tags;
        if (!Array.isArray(tags)) {
            return callback(new Error('Expected an array of tags, but received: ' + packageRaw.tags));
        }

        var tag = minSatisfying(tags, engine, undefined);

        // check if master is on the version specified
        if (!tag) {
            var version = packageRaw.version;
            if (semver.satisfies(version, engine)) {
                return callback(null, currentSource + '/master/.apis/wing.d.ts'); // master
            }
            return callback('Could not find satifying wing for version ' + engine + ' in the tags: [' + tags.join(', ') + '] or on master: ' + version);
        }

        console.log('Found minimal version that qualifies engine range: ' + tag);

        return callback(null, currentSource + '/master/.apis/wing-' + tag + '.d.ts');
    });
}

function minSatisfying(versions, range, loose) {
    return versions.filter(function (version) {
        try {
            return semver.satisfies(version, range, loose);
        } catch (error) {
            return false; // version might be invalid so we return as not matching
        };
    }).sort(function (a, b) {
        return semver.compare(a, b, loose);
    })[0] || null;
}

function exitWithError(error) {
    if (typeof error === 'string') {
        error = new Error(error);
    }
    console.error('Error installing wing.d.ts: ' + error.stack.toString());
    process.exit(1);
}

function getContents(url, callback) {
    var headers = {
        'user-agent': 'nodejs'
    }

    if (process.env.GITHUB_TOKEN) {
        headers['Authorization'] = 'token ' + process.env.GITHUB_TOKEN;
    }

    var options = {
        url: url,
        headers: headers
    };

    request.getContents(options, function (error, response, body) {
        callback(error, body);
    });
}